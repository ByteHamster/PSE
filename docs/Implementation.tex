\documentclass[parskip=full]{scrartcl}
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage{hyperref}
\usepackage[toc, nonumberlist]{glossaries}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{float}
\usepackage{color}

\hypersetup{
  colorlinks=false,
  linktoc=all,
  hidelinks,
}

\title{OSIP - Implementierung}
\subtitle{OPC UA Simulator for Industrial Plants}
\author{
    M. Armbruster\\
    D. Kahles\\
    H. Lehmann\\
    M. Schwarzmann\\
    N. Wilhelm
}

\begin{document}
\maketitle
\thispagestyle{empty}
\vspace{20px}
\begin{center}
  \includegraphics[scale=0.4]{../icon.png}
\end{center}
\pagebreak
\tableofcontents
\pagebreak

\section{Einleitung}


\section{Workflow}
OSIP wurde von uns open-source mit Hilfe von GitHub entwickelt. Um die Qualität des Codes möglichst gut zu halten,
haben wir konsequent Code-Reviews eingesetzt. Jede Änderung musste von einem Kommilitonen genehmigt werden. Zusätzlich ließen wir
durch den Dienst "`Travis"' bei jeder einzubindenden Änderung die Stil-Richtlinien für den Code (mittels Checkstyle) und die Unit Tests überprüfen.
Dieses Vorgehen erforderte zwar oft lange Wartezeiten auf Reviews, im Sinne der guten Qualität haben wir uns allerdings darauf eingelassen. 

Um die Aufgaben der einzelnen Kommilitonen aufeinander abzustimmen, setzten wir den von GitHub bereitgestellten Issue-Tracker ein. Im Laufe der
Entwicklung von OSIP wurden über 400 Issues und Pull requests erstellt.

\section{Arbeitsaufteilung}
Bei der Implementierung gingen nach dem bottom-up-Prinzip vor. Während Model, OPC UA Wrapper und Core-Bestandteile von David, Hans-Peter und Max entwickelt wurden,
begannen Martin und Niko mit den Benutzeroberflächen von Überwachungskonsole und Fertigungssimulation. Auf Grund des modularen Entwurfes
und der automatischen Generierung von Quellcode aus dem Klassendiagramm war dies problemlos möglich. Nachdem dann die Bestandteile einzeln
implementiert waren, wurden noch die Controller hinzugefügt, die jeweils Model und View verbinden, um so Leben in die Anwendung zu bringen.

\section{Änderungen zum Entwurf}


\section{Implementierte Muss- und Kannkriterien}


\section{Verzögerungen im Implementierungsplan}


\section{Probleme bei der Implementierung}
Im Pflichtenheft war geplant, die von OPC UA bereitgestellten Alarme zu benutzen, um bei einem ungewöhnlichen Zustand (z.B. Überlauf)
die Überwachungskonsole zu benachrichtigen. Leider unterstützt der Milo Server keine Alarme, siehe auch die entsprechende Antwort
des Milo-Entwicklers auf Stack Overflow: \href{http://stackoverflow.com/a/42161092/}{http://stackoverflow.com/a/42161092/}.
Somit mussten wir auch bei den Alarmen auf reguläre Subscriptions zurückgreifen, welche wir nun mit einem kürzeren Intervall
als die restlichen Produktionsvariablen abfragen.

\section{Unit tests}
Unit tests waren ausschlaggebend wichtig für den ersten Teil der Implementierung, bei dem die Controller noch nicht entwickelt waren.
Entsprechend ist die Testabdeckung sehr hoch. Das Model besitzt eine Zeilenabdeckung von 93\%, ebenso wie die Core-Bestandteile.
Um die Funktionalität von OPC UA Server und Client zu testen, musste von reinen unit tests abgewichen werden, da der Client keine
Methoden zum Setzen von Werten besitzt. Es wurde somit ein weiteres Modul hinzugefügt, das die Tests der Server- und Client-Module übernimmt.
Dieses Modul testet gleichzeitig das Client-Modul und das Server-Modul zu OPC UA, stellt also eher einen Integrationstest dar. Zur bottom-up
Entwicklung der OPC UA Abstraktion war dies aber unumgänglich. Durch die Tests konnte bei OPC UA eine Abdeckung von 78\% erreicht werden.

In UI und Controller wurden keine automatischen Unit tests eingesetzt, sondern die Funktionalität bei Pull requests manuell getestet.

\pagebreak
\phantomsection
\addcontentsline{toc}{section}{\listfigurename}
\listoffigures

\end{document}
